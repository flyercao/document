## 设计原则
稳定性:系统服务稳定、处理结果稳定。
安全性
兼容性
扩展性
可维护性
性能：

服务拆分：单一职责（业务领域、通用功能）、服务粒度适中、考虑团队结构、以业务模型切入、演进式拆分、避免环形依赖和双向依赖
服务无状态：服务处理结果跟运行环境无关，确保系统扩展性
接口幂等：同一个业务请求多次调用的结果等同于一次调用。可通过唯一ID、业务状态、禁止retry等方式解决。
安全回滚：在异常处理时，除了数据库事务回滚，还需要回滚计数器、消息数据等。
策略可定义：所有策略可以在线上新增、修改、作废、过期。
异步非阻塞：非核心流程采用异步方式处理。消息异步、日志异步、生产者消费者异步、多线程异步、

## 设计模式
工厂模式：Spring使用工厂模式，通过BeanFactory和ApplicationContext来创建对象。
单例模式：Bean默认为单例模式。
策略模式：例如Resource的实现类，针对不同的资源文件，实现了不同方式的资源获取策略。
代理模式:静态代理和动态代理，JDK动态代理（接口）和CGLIB动态代理。
模板方法：可以将相同部分的代码放在父类中，而将不同的代码放入不同的子类中，用来解决代码重复的问题。比如RestTemplate, JmsTemplate, JpaTemplate。
观察者模式：消费者不需要等待结果，通过注册一个观察者，当结果完成后，由观察者通知消费者。
责任链模式：将所有复合Filter接口的实现串连起来，添加新功能时，只需要实现接口并加入责任链即可，方便扩展。
适配器模式：通过适配器模式，将原本不复合规范（或不能直接使用）的组件进行包装，使其复合规范。比如日志框架slf4j。


## DDD领域驱动设计
关注业务领域（边界，领域对象和功能）
相反：关注数据和方法过程。

https://baijiahao.baidu.com/s?id=1688916329743913023&wfr=spider&for=pc
https://www.pianshen.com/article/5554360927/
## 大数据实时风控平台设计（海量、高性能、实时）
覆盖曹操出行全平台业务流程，登录注册、营销、订单、财务、派单等核心场景。通过规则策略+算法模型对风险和作弊行为进行实时识别和管控，取得很好的效果，严格口径下年挽回损失4000万。
日活近千万，百万订单，亿级请求。
压测环境红包活动场景下单机1万QPS。rt2ms。（频繁gc、CPU占用95%、load10+）
### 网关接入层（全异步非阻塞）
风控系统对外网关，接口对接、请求隔离、限流、熔断、降级、参数校验、登录数据补全、接入管理（场景事件配置）（轻量、配置化、隔离）
异步无阻塞网关：服务端异步执行AsyncContext+客户端异步调用+客户端事件通知实现异步网关
sync->Future->callback->CompletableFuture
压测环境红包活动场景下单机2万QPS。rt10ms。（频繁gc、CPU占用95%）
AKKA：完全消息驱动模型。
dubbo
### 风控业务层
针对业务领域相关逻辑处理，比如登录注册风险用户打标、叫单特殊参数处理、信用额度处理等；
### 风控核心层：
风控系统的核心。包含名单中心、策略引擎中心、处罚中心、案件中心等。
**名单中心**提供包括黑、白、其他等（用户号、手机号、设备号等各种维度）名单列表的匹配查询服务和简单逻辑判断服务。通过本地缓存（guava cache、bitmap）、分布式缓存（redis）和mysql持久化数据。
**策略引擎中心**提供风控策略的关联、解析、执行、结果汇总等功能。通过自研的脚本引擎高效的执行规则脚本。1.执行效率；2.兼容原有规则语法。启动加载并缓存实例；JIT预热；小脚本合并；独立classloader负责加载临时脚本class（防止Metaspace空间不足）。
**处罚中心**根据策略执行结果，决定相应的处罚措施（拉黑名单、提示充值、静默叫车等）
**案件中心**对触发风控策略的请求生成案件，以便后续人工核查和问题排查。ES保存数据查询索引，MongoDB保存案件详情。
批量请求合并处理（减少特征查询）；分批次执行策略（减少执行耗时策略）；小脚本合并；异步处罚；异步案件；案件查询优化；

### 特征查询层：（高性能、高可用）
根据事件下规则和特征配置，查询当前请求关联的所有特征。基础特征支持redis、MongoDB、hbase等存储数据查询和dubbo接口、模型接口、三方服务接口等多种特征的查询。复合特征是在对基础特征进行加工得到（写加工、读加工）。  
**查询合并**将同一个用户的不同车型订单关联的特征分类为订单相关和订单无关特征，将所有订单无关特征合并为一次查询，减少重复查询。
**动态超时控制**根据请求超时时间和请求已消耗的时间，动态计算当前节点的可用时间，避免线程无用等待。
**特征缓存**针对外部接口很耗时数据，进行redis缓存和本地缓存。
**特征拆解**实时+离线：
**提前缓存**登录时提前加载用户画像、设备画像等数据到缓存；定时加载画像数据到缓存；
**预处理**登录时计算用户账号、设备、网络环境等相关风险数据。
**多种计算时机**针对复合特征，提供写入计算和查询计算两种数据处理方式。

### 数据计算层（实时、准确、高性能）
指标计算中心：通过flink任务对业务kafka数据进行清洗、聚合、加工等处理，得到实时的风控指标。
实时特征计算：通过实时任务对用户特征（未支付订单数）进行较复杂的关联计算。实时数据保存在redis缓存。
离线特征计算（用户画像、设备画像）：离线任务计算历史画像数据，全量保存在ES宽表，热点数据缓存。
风险评分：
信用评分：
基于Lambda 实时+离线 架构。通过Hive SQL、flink、jstorm等批量和实时任务对业务数据进行聚合计算，并保存到codis、mongodb、hbase、ES等数据库。用户画像、信用额度、订单数据、设备风险、实时指标、黑白名单统计、

审核管理：事件、场景、策略、特征的配置管理；风控案件的审核：ES+MongoDB。
业务统计和监控：统计报表配置、业务指标监控以及异常监控和报警；
组件层：设备指纹、一键登录、手机号风险、人机识别等组件一般通过采购外部资源、独立部署，降低成本、快速上线。



查算分离：查询逻辑与特征处理逻辑分开部署。未支付单聚合计算、实时指标平台

实时聚合：实时聚合统计业务指标数据。
特征聚合：高性能场景空间换时间；低性能时间换空间
特征拆解：实时+离线：对于时间跨度长的特征，拆分为实时和离线两个特征。离线数据跨天未计算时，则实时部分需要累积前一天的数据。
登录预处理：登录预加载缓存；登录预计算；
画像热加载：定时加载热数据


### 建设方向

模型效果评估：解决传统模型效果评估周期长（开发、上线、观察、分析）的难题，通过对线上流量和特征进行回放，收集模型命中结果数据与预期进行实时对比分析，快速发现模型缺陷并进行迭代。
动态对接风控系统：解决风控被动对接业务系统存在遗漏和延迟的问题，通过代码注入的方式在业务系统关键点加入风控数据采集和逻辑判断代码，主动发现和管控业务风险。

无阻塞模式（IO密集型应用）  减少上下文切换以及线程阻塞唤醒调度
同步 -> 异步阻塞(future) -> 异步非阻塞(callback) -> 
**CompletableFuture**:异步流程控制。实现了Future和CompletionStage接口，实现非常复杂的异步计算工作。底层还是通过线程池去异步执行，通过阻塞等方式通信。
**Spring5 WebFlux、Reactor**等事件驱动响应式编程框架：使用发布者 – 订阅者方式来解决传统编程同步阻塞、回调地狱；编程思维方式难转变，没有堆栈不便于调试。
**协程(Coroutine)**：Kotlin、Quasar等轻量级线程。同步的编程方式达到或接近于纯异步的性能，而没有异步带来的Callback hell。 fiber blocking可以达到比thread blocking大几个数量级的并发度，更有效的利用CPU资源(运行fiber的worker线程并没有block)
通过字节码修改技术在编译或载入时织入必要的上下文保存/恢复代码，通过抛异常来暂停，恢复的时候根据保存的上下文(Continuation),恢复jvm的方法调用栈和局部变量。对代码有一定的侵入。另外，还不支持DB、MQ等阻塞接口。
**AJDK WISP**Java协程，与Quasar原理类似。号称完全兼容现有的Java代码，阿里巴巴双十一实践。多线程的IO密集的Java应用。
**Project Loom**:异步编程最佳的实现方式(同步编程、异步执行)。是在JVM上实现轻量级的线程，并解除JVM线程与内核线程的一对一映射关系。避免线程阻塞、上下文等待。
趋势：HTTP1.1短连接方式减少，直播、语音、视频、游戏、AR/VR等IO密集和流式应用场景需要更高的并发
https://www.jianshu.com/p/5db701a764cb

进程：一个运行的程序或代码就是一个进程。进程是系统进行资源分配的最小单位，进程拥有自己的内存空间，进程之间相互独立，所以进程间数据不共享，开销大，同一个进程中的所有线程共享资源。适合CPU密集计算。
线程：操作系统调度执行的最小单位。不能独立存在，依赖进程的存在而存在，一个进程至少有一个线程，叫主线程，多个线程共享内存（数据共享和全局变量），因此提升程序的运行效率。IO密集型应用、CPU利用率低。
协程：用户态的轻量级线程，调度由应用控制，操作系统不直接参与调度。拥有自己的寄存器上下文和栈，切换基本没有内核切换的开销，切换灵活。