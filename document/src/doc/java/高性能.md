
#### 高性能
服务拆分：按业务、系统、读写、实时离线维度将服务拆分成更细的粒度。
分布式服务：同一应用部署在多台机器，通过负载均衡策略分发请求。

并发：合理多线程数量，线程利用率，减少线程阻塞（blocked）和等待（waiting）频繁切换带来的开销；
异步：异步队列（生产者消费者）、异步日志log4j2、异步发消息、dubbo future异步
锁优化：synchronized-》reentrantlock-》CAS -》disruptor
多级缓存：本地缓存、分布式缓存（登录预加载，指标缓存）
批量：批量写hbase、MongoDB、mysql数据库
读写分离：1. 数据存储层面读写分离；2. 通过消费kafka消息异步写入
数据聚合：指标查询场景，通过实时任务对数据进行聚合统计，而不是查询时统计。
实时特征拆分：将时间跨度长的实时特征拆分为T-N离线特征和近N天实时特征。
连接池：http连接池，数据库连接池。避免频繁建立连接和断开连接。绿码服务使用CloseableHttpClient，并调整重试策略（）

全异步网关：减少线程阻塞，提高利用率。
提前缓存：**登录**预加载画像数据到缓存、**热点数据**提前加载缓存。
预处理：登录、叫单等节点进行设备环境相关特征的计算并缓存。
高性能脚本引擎：采用自研编译型脚本引擎替换解释型的jexl引擎（提前触发JIT编译）；多个小脚本合并成大脚本；本地缓存实例；每个脚本单独ClassLoader，避免共用同一个ClassLoader导致脚本class无法被卸载。调整JIT codeCache初始大小和预留大小。
写计算：对于实时性要求高的场景，复合特征的计算由查询时计算调整为写入式计算。（以空间换时间）
#### 高可用
优先级：设置线程priority优先级属性，实现不同业务的处理优先级。
幂等：对于写入场景，同一个请求被consumer多次调用，产生的影响与一次调用一致。  
超时：合理控制接口时间，快速失败。
重试：对于**查询**接口偶尔出现超时，选择另一个节点进行重新调用。
隔离：信号量隔离；线程池隔离；dubbo接口提供者自定义ExecuteLimitFilter，根据请求参数限制每个业务场景分配的线程数；
限流：信号量Semaphore限流；原子计数器AtomicLong限流；guava ratelimitor限流（令牌桶）；dubbo限流器DefaultTPSLimiter（漏桶）
熔断：对于频繁超时的非核心应用直接短路，并尝试恢复的机制。底层依赖hystrix实现。特征层熔断降级
降级：dubbo mock配置降级策略和默认值；hystrix配置降级；大促期间，手动配置业务降级；
补偿：失败数据保存消息队列或本地日志文件，事后特殊处理或人工手动维护。
业务监控
系统监控
报警

### 异地双活
由于网络延迟导致数据冲突或不一致情况，需要权衡吞吐量和一致性。通过引入分布式锁/分布式事务保障一致性；也可以通过中间软状态，最终一致性等保障吞吐量。
一般通过数据同步工具、消息队列等保障数据最终一致性。对于一致性要求严格的场景，采用主从数据库方案。
对于简单业务场景，直接按业务维度进行sharding即可，必比如按照全国划分区域，跨区域的数据需要特殊处理。

1.两地三中心切线，业务代码返回特定错误码（例如数据库异常，一般表示某个中心可能存在down机或不可用的的可能性），客户端进行切线。
2.多次重试请求后不可用，进行切线。


发布流程
灰度发布
线上配置
功能开关
代码回滚

